<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>求Fibonacci数列的两种实现方式</title>
    <url>/2019/12/13/fibonacci/</url>
    <content><![CDATA[<h1 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><div class="table-container">
<table>
<thead>
<tr>
<th>1</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>5</th>
<th>8</th>
<th>….</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>从第3项开始，每一项都等于前两项之和。</p>
</blockquote>
<p><strong>表达式:</strong></p>
<script type="math/tex; mode=display">f(i)=\begin{cases}
1 & i=1,2\\
 f(i-1)+f(i-2)& i>2 
\end{cases}</script><h2 id="C语言递归实现"><a href="#C语言递归实现" class="headerlink" title="C语言递归实现"></a>C语言递归实现</h2><p>通过定义可以容易写出fibinacci数列递归形式<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || i == <span class="number">1</span>)<span class="comment">//数组从下标0开始</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fib(i - <span class="number">1</span>) + Fib(i - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 设值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = Fib(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>在某些时刻,递归思考起来很简答,但是它的效率不高.<br>如果能直接获得前两项的值$f(i-1)和f(i-2)$而不是一层一层的递归下去求解,那么效率明显会提高.<br>设数组$a[i]=a[i-1]+a[i-2]$是不是和上面的式子很像.但这里数组可以直接通过下标取值,不需要一层一层递归下区求解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 设置前两项的值</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>如果你对递归和非递归的效率问题还不是很理解,当你把上面代码中的求前20项的数值改大一些你就能感受到二者的效率差别.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序C语言实现</title>
    <url>/2019/12/12/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="冒泡算法排序"><a href="#冒泡算法排序" class="headerlink" title="冒泡算法排序"></a>冒泡算法排序</h1><blockquote>
<p>冒泡算法是一种交换排序,每一次将最大/最小的数字 移动到末尾</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考:"></a>思考:</h2><ol>
<li>假设有n个数,每次遍历将最大/最小的数字交换到最后.</li>
<li>对剩下的n-1个数重复1的步骤.</li>
<li>当只剩下一个数字,或者某次遍历过程未发生交换时,排序结束.</li>
</ol>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><p><strong>bubbleSort.c</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> keys[], <span class="keyword">int</span> n, <span class="keyword">int</span> asc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; exchange; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (asc ? keys[j] &gt; keys[j + <span class="number">1</span>] : keys[j] &lt; keys[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(keys, j, j + <span class="number">1</span>);</span><br><span class="line">                exchange = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
        <tag>bubbleSort</tag>
      </tags>
  </entry>
  <entry>
    <title>输出100内的素数</title>
    <url>/2019/12/12/%E8%BE%93%E5%87%BA100%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<h1 id="输出100内素数的C语言实现"><a href="#输出100内素数的C语言实现" class="headerlink" title="输出100内素数的C语言实现"></a>输出100内素数的C语言实现</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><blockquote>
<p>素数(质数)在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><ol>
<li>假定一个大于1的整数n是素数(从2开始)</li>
<li>那么n%i(i=2,3,.,.,.,n-1)都不等于0,那么这个数字是素数.</li>
<li>输出数字n.</li>
</ol>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><p><strong>isPrime.c</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">int</span> isPrime = <span class="number">1</span>;<span class="comment">//假设i是素数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (i % j == <span class="number">0</span>)<span class="comment">//不满足素数条件</span></span><br><span class="line">          &#123;</span><br><span class="line">              isPrime = <span class="number">0</span>;<span class="comment">//确认这个数不是素数</span></span><br><span class="line">              <span class="keyword">break</span>;<span class="comment">//跳出这个循环</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isPrime)<span class="comment">//判断i是不是素数</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
</search>
